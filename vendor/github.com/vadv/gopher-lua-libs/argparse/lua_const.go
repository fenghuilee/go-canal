// GENERATED BY textFileToGoConst
// GitHub:     github.com/logrusorgru/textFileToGoConst
// input file: argparse.lua
// generated:  Sat Nov  5 20:30:23 PDT 2022

package argparse

const lua_argparse = "-- The MIT License (MIT)\n\n-- Copyright (c) 2013 - 2018 Peter Melnichenko\n--                      2019 Paul Ouellette\n\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n-- the Software, and to permit persons to whom the Software is furnished to do so,\n-- subject to the following conditions:\n\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n-- FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n-- COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n-- IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nlocal function deep_update(t1, t2)\n    for k, v in pairs(t2) do\n        if type(v) == \"table\" then\n            v = deep_update({}, v)\n        end\n\n        t1[k] = v\n    end\n\n    return t1\nend\n\n-- A property is a tuple {name, callback}.\n-- properties.args is number of properties that can be set as arguments\n-- when calling an object.\nlocal function class(prototype, properties, parent)\n    -- Class is the metatable of its instances.\n    local cl = {}\n    cl.__index = cl\n\n    if parent then\n        cl.__prototype = deep_update(deep_update({}, parent.__prototype), prototype)\n    else\n        cl.__prototype = prototype\n    end\n\n    if properties then\n        local names = {}\n\n        -- Create setter methods and fill set of property names.\n        for _, property in ipairs(properties) do\n            local name, callback = property[1], property[2]\n\n            cl[name] = function(self, value)\n                if not callback(self, value) then\n                    self[\"_\" .. name] = value\n                end\n\n                return self\n            end\n\n            names[name] = true\n        end\n\n        function cl.__call(self, ...)\n            -- When calling an object, if the first argument is a table,\n            -- interpret keys as property names, else delegate arguments\n            -- to corresponding setters in order.\n            local first = ...\n            if type(first) == \"table\" then\n                for name, value in pairs(first) do\n                    if names[name] then\n                        self[name](self, value)\n                    end\n                end\n            else\n                local nargs = select(\"#\", ...)\n\n                for i, property in ipairs(properties) do\n                    if i > nargs or i > properties.args then\n                        break\n                    end\n\n                    local arg = select(i, ...)\n\n                    if arg ~= nil then\n                        self[property[1]](self, arg)\n                    end\n                end\n            end\n\n            return self\n        end\n    end\n\n    -- If indexing class fails, fallback to its parent.\n    local class_metatable = {}\n    class_metatable.__index = parent\n\n    function class_metatable.__call(self, ...)\n        -- Calling a class returns its instance.\n        -- Arguments are delegated to the instance.\n        local object = deep_update({}, self.__prototype)\n        setmetatable(object, self)\n        return object(...)\n    end\n\n    return setmetatable(cl, class_metatable)\nend\n\nlocal function typecheck(name, types, value)\n    for _, type_ in ipairs(types) do\n        if type(value) == type_ then\n            return true\n        end\n    end\n\n    error((\"bad property '%s' (%s expected, got %s)\"):format(name, table.concat(types, \" or \"), type(value)))\nend\n\nlocal function typechecked(name, ...)\n    local types = {...}\n    return {name, function(_, value) typecheck(name, types, value) end}\nend\n\nlocal multiname = {\"name\", function(self, value)\n    typecheck(\"name\", {\"string\"}, value)\n\n    for alias in value:gmatch(\"%S+\") do\n        self._name = self._name or alias\n        table.insert(self._aliases, alias)\n        table.insert(self._public_aliases, alias)\n        -- If alias contains '_', accept '-' also.\n        if alias:find(\"_\", 1, true) then\n            table.insert(self._aliases, (alias:gsub(\"_\", \"-\")))\n        end\n    end\n\n    -- Do not set _name as with other properties.\n    return true\nend}\n\nlocal multiname_hidden = {\"hidden_name\", function(self, value)\n    typecheck(\"hidden_name\", {\"string\"}, value)\n\n    for alias in value:gmatch(\"%S+\") do\n        table.insert(self._aliases, alias)\n        if alias:find(\"_\", 1, true) then\n            table.insert(self._aliases, (alias:gsub(\"_\", \"-\")))\n        end\n    end\n\n    return true\nend}\n\nlocal function parse_boundaries(str)\n    if tonumber(str) then\n        return tonumber(str), tonumber(str)\n    end\n\n    if str == \"*\" then\n        return 0, math.huge\n    end\n\n    if str == \"+\" then\n        return 1, math.huge\n    end\n\n    if str == \"?\" then\n        return 0, 1\n    end\n\n    if str:match \"^%d+%-%d+$\" then\n        local min, max = str:match \"^(%d+)%-(%d+)$\"\n        return tonumber(min), tonumber(max)\n    end\n\n    if str:match \"^%d+%+$\" then\n        local min = str:match \"^(%d+)%+$\"\n        return tonumber(min), math.huge\n    end\nend\n\nlocal function boundaries(name)\n    return {name, function(self, value)\n        typecheck(name, {\"number\", \"string\"}, value)\n\n        local min, max = parse_boundaries(value)\n\n        if not min then\n            error((\"bad property '%s'\"):format(name))\n        end\n\n        self[\"_min\" .. name], self[\"_max\" .. name] = min, max\n    end}\nend\n\nlocal actions = {}\n\nlocal option_action = {\"action\", function(_, value)\n    typecheck(\"action\", {\"function\", \"string\"}, value)\n\n    if type(value) == \"string\" and not actions[value] then\n        error((\"unknown action '%s'\"):format(value))\n    end\nend}\n\nlocal option_init = {\"init\", function(self)\n    self._has_init = true\nend}\n\nlocal option_default = {\"default\", function(self, value)\n    if type(value) ~= \"string\" then\n        self._init = value\n        self._has_init = true\n        return true\n    end\nend}\n\nlocal add_help = {\"add_help\", function(self, value)\n    typecheck(\"add_help\", {\"boolean\", \"string\", \"table\"}, value)\n\n    if self._help_option_idx then\n        table.remove(self._options, self._help_option_idx)\n        self._help_option_idx = nil\n    end\n\n    if value then\n        local help = self:flag()\n                         :description \"Show this help message and exit.\"\n                         :action(function()\n            print(self:get_help())\n            os.exit(0)\n        end)\n\n        if value ~= true then\n            help = help(value)\n        end\n\n        if not help._name then\n            help \"-h\" \"--help\"\n        end\n\n        self._help_option_idx = #self._options\n    end\nend}\n\nlocal Parser = class({\n    _arguments = {},\n    _options = {},\n    _commands = {},\n    _mutexes = {},\n    _groups = {},\n    _require_command = true,\n    _handle_options = true\n}, {\n    args = 3,\n    typechecked(\"name\", \"string\"),\n    typechecked(\"description\", \"string\"),\n    typechecked(\"epilog\", \"string\"),\n    typechecked(\"usage\", \"string\"),\n    typechecked(\"help\", \"string\"),\n    typechecked(\"require_command\", \"boolean\"),\n    typechecked(\"handle_options\", \"boolean\"),\n    typechecked(\"action\", \"function\"),\n    typechecked(\"command_target\", \"string\"),\n    typechecked(\"help_vertical_space\", \"number\"),\n    typechecked(\"usage_margin\", \"number\"),\n    typechecked(\"usage_max_width\", \"number\"),\n    typechecked(\"help_usage_margin\", \"number\"),\n    typechecked(\"help_description_margin\", \"number\"),\n    typechecked(\"help_max_width\", \"number\"),\n    add_help\n})\n\nlocal Command = class({\n    _aliases = {},\n    _public_aliases = {}\n}, {\n    args = 3,\n    multiname,\n    typechecked(\"description\", \"string\"),\n    typechecked(\"epilog\", \"string\"),\n    multiname_hidden,\n    typechecked(\"summary\", \"string\"),\n    typechecked(\"target\", \"string\"),\n    typechecked(\"usage\", \"string\"),\n    typechecked(\"help\", \"string\"),\n    typechecked(\"require_command\", \"boolean\"),\n    typechecked(\"handle_options\", \"boolean\"),\n    typechecked(\"action\", \"function\"),\n    typechecked(\"command_target\", \"string\"),\n    typechecked(\"help_vertical_space\", \"number\"),\n    typechecked(\"usage_margin\", \"number\"),\n    typechecked(\"usage_max_width\", \"number\"),\n    typechecked(\"help_usage_margin\", \"number\"),\n    typechecked(\"help_description_margin\", \"number\"),\n    typechecked(\"help_max_width\", \"number\"),\n    typechecked(\"hidden\", \"boolean\"),\n    add_help\n}, Parser)\n\nlocal Argument = class({\n    _minargs = 1,\n    _maxargs = 1,\n    _mincount = 1,\n    _maxcount = 1,\n    _defmode = \"unused\",\n    _show_default = true\n}, {\n    args = 5,\n    typechecked(\"name\", \"string\"),\n    typechecked(\"description\", \"string\"),\n    option_default,\n    typechecked(\"convert\", \"function\", \"table\"),\n    boundaries(\"args\"),\n    typechecked(\"target\", \"string\"),\n    typechecked(\"defmode\", \"string\"),\n    typechecked(\"show_default\", \"boolean\"),\n    typechecked(\"argname\", \"string\", \"table\"),\n    typechecked(\"choices\", \"table\"),\n    typechecked(\"hidden\", \"boolean\"),\n    option_action,\n    option_init\n})\n\nlocal Option = class({\n    _aliases = {},\n    _public_aliases = {},\n    _mincount = 0,\n    _overwrite = true\n}, {\n    args = 6,\n    multiname,\n    typechecked(\"description\", \"string\"),\n    option_default,\n    typechecked(\"convert\", \"function\", \"table\"),\n    boundaries(\"args\"),\n    boundaries(\"count\"),\n    multiname_hidden,\n    typechecked(\"target\", \"string\"),\n    typechecked(\"defmode\", \"string\"),\n    typechecked(\"show_default\", \"boolean\"),\n    typechecked(\"overwrite\", \"boolean\"),\n    typechecked(\"argname\", \"string\", \"table\"),\n    typechecked(\"choices\", \"table\"),\n    typechecked(\"hidden\", \"boolean\"),\n    option_action,\n    option_init\n}, Argument)\n\nfunction Parser:_inherit_property(name, default)\n    local element = self\n\n    while true do\n        local value = element[\"_\" .. name]\n\n        if value ~= nil then\n            return value\n        end\n\n        if not element._parent then\n            return default\n        end\n\n        element = element._parent\n    end\nend\n\nfunction Argument:_get_argument_list()\n    local buf = {}\n    local i = 1\n\n    while i <= math.min(self._minargs, 3) do\n        local argname = self:_get_argname(i)\n\n        if self._default and self._defmode:find \"a\" then\n            argname = \"[\" .. argname .. \"]\"\n        end\n\n        table.insert(buf, argname)\n        i = i+1\n    end\n\n    while i <= math.min(self._maxargs, 3) do\n        table.insert(buf, \"[\" .. self:_get_argname(i) .. \"]\")\n        i = i+1\n\n        if self._maxargs == math.huge then\n            break\n        end\n    end\n\n    if i < self._maxargs then\n        table.insert(buf, \"...\")\n    end\n\n    return buf\nend\n\nfunction Argument:_get_usage()\n    local usage = table.concat(self:_get_argument_list(), \" \")\n\n    if self._default and self._defmode:find \"u\" then\n        if self._maxargs > 1 or (self._minargs == 1 and not self._defmode:find \"a\") then\n            usage = \"[\" .. usage .. \"]\"\n        end\n    end\n\n    return usage\nend\n\nfunction actions.store_true(result, target)\n    result[target] = true\nend\n\nfunction actions.store_false(result, target)\n    result[target] = false\nend\n\nfunction actions.store(result, target, argument)\n    result[target] = argument\nend\n\nfunction actions.count(result, target, _, overwrite)\n    if not overwrite then\n        result[target] = result[target] + 1\n    end\nend\n\nfunction actions.append(result, target, argument, overwrite)\n    result[target] = result[target] or {}\n    table.insert(result[target], argument)\n\n    if overwrite then\n        table.remove(result[target], 1)\n    end\nend\n\nfunction actions.concat(result, target, arguments, overwrite)\n    if overwrite then\n        error(\"'concat' action can't handle too many invocations\")\n    end\n\n    result[target] = result[target] or {}\n\n    for _, argument in ipairs(arguments) do\n        table.insert(result[target], argument)\n    end\nend\n\nfunction Argument:_get_action()\n    local action, init\n\n    if self._maxcount == 1 then\n        if self._maxargs == 0 then\n            action, init = \"store_true\", nil\n        else\n            action, init = \"store\", nil\n        end\n    else\n        if self._maxargs == 0 then\n            action, init = \"count\", 0\n        else\n            action, init = \"append\", {}\n        end\n    end\n\n    if self._action then\n        action = self._action\n    end\n\n    if self._has_init then\n        init = self._init\n    end\n\n    if type(action) == \"string\" then\n        action = actions[action]\n    end\n\n    return action, init\nend\n\n-- Returns placeholder for `narg`-th argument.\nfunction Argument:_get_argname(narg)\n    local argname = self._argname or self:_get_default_argname()\n\n    if type(argname) == \"table\" then\n        return argname[narg]\n    else\n        return argname\n    end\nend\n\nfunction Argument:_get_choices_list()\n    return \"{\" .. table.concat(self._choices, \",\") .. \"}\"\nend\n\nfunction Argument:_get_default_argname()\n    if self._choices then\n        return self:_get_choices_list()\n    else\n        return \"<\" .. self._name .. \">\"\n    end\nend\n\nfunction Option:_get_default_argname()\n    if self._choices then\n        return self:_get_choices_list()\n    else\n        return \"<\" .. self:_get_default_target() .. \">\"\n    end\nend\n\n-- Returns labels to be shown in the help message.\nfunction Argument:_get_label_lines()\n    if self._choices then\n        return {self:_get_choices_list()}\n    else\n        return {self._name}\n    end\nend\n\nfunction Option:_get_label_lines()\n    local argument_list = self:_get_argument_list()\n\n    if #argument_list == 0 then\n        -- Don't put aliases for simple flags like `-h` on different lines.\n        return {table.concat(self._public_aliases, \", \")}\n    end\n\n    local longest_alias_length = -1\n\n    for _, alias in ipairs(self._public_aliases) do\n        longest_alias_length = math.max(longest_alias_length, #alias)\n    end\n\n    local argument_list_repr = table.concat(argument_list, \" \")\n    local lines = {}\n\n    for i, alias in ipairs(self._public_aliases) do\n        local line = (\" \"):rep(longest_alias_length - #alias) .. alias .. \" \" .. argument_list_repr\n\n        if i ~= #self._public_aliases then\n            line = line .. \",\"\n        end\n\n        table.insert(lines, line)\n    end\n\n    return lines\nend\n\nfunction Command:_get_label_lines()\n    return {table.concat(self._public_aliases, \", \")}\nend\n\nfunction Argument:_get_description()\n    if self._default and self._show_default then\n        if self._description then\n            return (\"%s (default: %s)\"):format(self._description, self._default)\n        else\n            return (\"default: %s\"):format(self._default)\n        end\n    else\n        return self._description or \"\"\n    end\nend\n\nfunction Command:_get_description()\n    return self._summary or self._description or \"\"\nend\n\nfunction Option:_get_usage()\n    local usage = self:_get_argument_list()\n    table.insert(usage, 1, self._name)\n    usage = table.concat(usage, \" \")\n\n    if self._mincount == 0 or self._default then\n        usage = \"[\" .. usage .. \"]\"\n    end\n\n    return usage\nend\n\nfunction Argument:_get_default_target()\n    return self._name\nend\n\nfunction Option:_get_default_target()\n    local res\n\n    for _, alias in ipairs(self._public_aliases) do\n        if alias:sub(1, 1) == alias:sub(2, 2) then\n            res = alias:sub(3)\n            break\n        end\n    end\n\n    res = res or self._name:sub(2)\n    return (res:gsub(\"-\", \"_\"))\nend\n\nfunction Option:_is_vararg()\n    return self._maxargs ~= self._minargs\nend\n\nfunction Parser:_get_fullname(exclude_root)\n    local parent = self._parent\n    if exclude_root and not parent then\n        return \"\"\n    end\n    local buf = {self._name}\n\n    while parent do\n        if not exclude_root or parent._parent then\n            table.insert(buf, 1, parent._name)\n        end\n        parent = parent._parent\n    end\n\n    return table.concat(buf, \" \")\nend\n\nfunction Parser:_update_charset(charset)\n    charset = charset or {}\n\n    for _, command in ipairs(self._commands) do\n        command:_update_charset(charset)\n    end\n\n    for _, option in ipairs(self._options) do\n        for _, alias in ipairs(option._aliases) do\n            charset[alias:sub(1, 1)] = true\n        end\n    end\n\n    return charset\nend\n\nfunction Parser:argument(...)\n    local argument = Argument(...)\n    table.insert(self._arguments, argument)\n    return argument\nend\n\nfunction Parser:option(...)\n    local option = Option(...)\n    table.insert(self._options, option)\n    return option\nend\n\nfunction Parser:flag(...)\n    return self:option():args(0)(...)\nend\n\nfunction Parser:command(...)\n    local command = Command():add_help(true)(...)\n    command._parent = self\n    table.insert(self._commands, command)\n    return command\nend\n\nfunction Parser:mutex(...)\n    local elements = {...}\n\n    for i, element in ipairs(elements) do\n        local mt = getmetatable(element)\n        assert(mt == Option or mt == Argument, (\"bad argument #%d to 'mutex' (Option or Argument expected)\"):format(i))\n    end\n\n    table.insert(self._mutexes, elements)\n    return self\nend\n\nfunction Parser:group(name, ...)\n    assert(type(name) == \"string\", (\"bad argument #1 to 'group' (string expected, got %s)\"):format(type(name)))\n\n    local group = {name = name, ...}\n\n    for i, element in ipairs(group) do\n        local mt = getmetatable(element)\n        assert(mt == Option or mt == Argument or mt == Command,\n                (\"bad argument #%d to 'group' (Option or Argument or Command expected)\"):format(i + 1))\n    end\n\n    table.insert(self._groups, group)\n    return self\nend\n\nlocal usage_welcome = \"Usage: \"\n\nfunction Parser:get_usage()\n    if self._usage then\n        return self._usage\n    end\n\n    local usage_margin = self:_inherit_property(\"usage_margin\", #usage_welcome)\n    local max_usage_width = self:_inherit_property(\"usage_max_width\", 70)\n    local lines = {usage_welcome .. self:_get_fullname()}\n\n    local function add(s)\n        if #lines[#lines]+1+#s <= max_usage_width then\n            lines[#lines] = lines[#lines] .. \" \" .. s\n        else\n            lines[#lines+1] = (\" \"):rep(usage_margin) .. s\n        end\n    end\n\n    -- Normally options are before positional arguments in usage messages.\n    -- However, vararg options should be after, because they can't be reliable used\n    -- before a positional argument.\n    -- Mutexes come into play, too, and are shown as soon as possible.\n    -- Overall, output usages in the following order:\n    -- 1. Mutexes that don't have positional arguments or vararg options.\n    -- 2. Options that are not in any mutexes and are not vararg.\n    -- 3. Positional arguments - on their own or as a part of a mutex.\n    -- 4. Remaining mutexes.\n    -- 5. Remaining options.\n\n    local elements_in_mutexes = {}\n    local added_elements = {}\n    local added_mutexes = {}\n    local argument_to_mutexes = {}\n\n    local function add_mutex(mutex, main_argument)\n        if added_mutexes[mutex] then\n            return\n        end\n\n        added_mutexes[mutex] = true\n        local buf = {}\n\n        for _, element in ipairs(mutex) do\n            if not element._hidden and not added_elements[element] then\n                if getmetatable(element) == Option or element == main_argument then\n                    table.insert(buf, element:_get_usage())\n                    added_elements[element] = true\n                end\n            end\n        end\n\n        if #buf == 1 then\n            add(buf[1])\n        elseif #buf > 1 then\n            add(\"(\" .. table.concat(buf, \" | \") .. \")\")\n        end\n    end\n\n    local function add_element(element)\n        if not element._hidden and not added_elements[element] then\n            add(element:_get_usage())\n            added_elements[element] = true\n        end\n    end\n\n    for _, mutex in ipairs(self._mutexes) do\n        local is_vararg = false\n        local has_argument = false\n\n        for _, element in ipairs(mutex) do\n            if getmetatable(element) == Option then\n                if element:_is_vararg() then\n                    is_vararg = true\n                end\n            else\n                has_argument = true\n                argument_to_mutexes[element] = argument_to_mutexes[element] or {}\n                table.insert(argument_to_mutexes[element], mutex)\n            end\n\n            elements_in_mutexes[element] = true\n        end\n\n        if not is_vararg and not has_argument then\n            add_mutex(mutex)\n        end\n    end\n\n    for _, option in ipairs(self._options) do\n        if not elements_in_mutexes[option] and not option:_is_vararg() then\n            add_element(option)\n        end\n    end\n\n    -- Add usages for positional arguments, together with one mutex containing them, if they are in a mutex.\n    for _, argument in ipairs(self._arguments) do\n        -- Pick a mutex as a part of which to show this argument, take the first one that's still available.\n        local mutex\n\n        if elements_in_mutexes[argument] then\n            for _, argument_mutex in ipairs(argument_to_mutexes[argument]) do\n                if not added_mutexes[argument_mutex] then\n                    mutex = argument_mutex\n                end\n            end\n        end\n\n        if mutex then\n            add_mutex(mutex, argument)\n        else\n            add_element(argument)\n        end\n    end\n\n    for _, mutex in ipairs(self._mutexes) do\n        add_mutex(mutex)\n    end\n\n    for _, option in ipairs(self._options) do\n        add_element(option)\n    end\n\n    if #self._commands > 0 then\n        if self._require_command then\n            add(\"<command>\")\n        else\n            add(\"[<command>]\")\n        end\n\n        add(\"...\")\n    end\n\n    return table.concat(lines, \"\\n\")\nend\n\nlocal function split_lines(s)\n    if s == \"\" then\n        return {}\n    end\n\n    local lines = {}\n\n    if s:sub(-1) ~= \"\\n\" then\n        s = s .. \"\\n\"\n    end\n\n    for line in s:gmatch(\"([^\\n]*)\\n\") do\n        table.insert(lines, line)\n    end\n\n    return lines\nend\n\nlocal function autowrap_line(line, max_length)\n    -- Algorithm for splitting lines is simple and greedy.\n    local result_lines = {}\n\n    -- Preserve original indentation of the line, put this at the beginning of each result line.\n    -- If the first word looks like a list marker ('*', '+', or '-'), add spaces so that starts\n    -- of the second and the following lines vertically align with the start of the second word.\n    local indentation = line:match(\"^ *\")\n\n    if line:find(\"^ *[%*%+%-]\") then\n        indentation = indentation .. \" \" .. line:match(\"^ *[%*%+%-]( *)\")\n    end\n\n    -- Parts of the last line being assembled.\n    local line_parts = {}\n\n    -- Length of the current line.\n    local line_length = 0\n\n    -- Index of the next character to consider.\n    local index = 1\n\n    while true do\n        local word_start, word_finish, word = line:find(\"([^ ]+)\", index)\n\n        if not word_start then\n            -- Ignore trailing spaces, if any.\n            break\n        end\n\n        local preceding_spaces = line:sub(index, word_start - 1)\n        index = word_finish + 1\n\n        if (#line_parts == 0) or (line_length + #preceding_spaces + #word <= max_length) then\n            -- Either this is the very first word or it fits as an addition to the current line, add it.\n            table.insert(line_parts, preceding_spaces) -- For the very first word this adds the indentation.\n            table.insert(line_parts, word)\n            line_length = line_length + #preceding_spaces + #word\n        else\n            -- Does not fit, finish current line and put the word into a new one.\n            table.insert(result_lines, table.concat(line_parts))\n            line_parts = {indentation, word}\n            line_length = #indentation + #word\n        end\n    end\n\n    if #line_parts > 0 then\n        table.insert(result_lines, table.concat(line_parts))\n    end\n\n    if #result_lines == 0 then\n        -- Preserve empty lines.\n        result_lines[1] = \"\"\n    end\n\n    return result_lines\nend\n\n-- Automatically wraps lines within given array,\n-- attempting to limit line length to `max_length`.\n-- Existing line splits are preserved.\nlocal function autowrap(lines, max_length)\n    local result_lines = {}\n\n    for _, line in ipairs(lines) do\n        local autowrapped_lines = autowrap_line(line, max_length)\n\n        for _, autowrapped_line in ipairs(autowrapped_lines) do\n            table.insert(result_lines, autowrapped_line)\n        end\n    end\n\n    return result_lines\nend\n\nfunction Parser:_get_element_help(element)\n    local label_lines = element:_get_label_lines()\n    local description_lines = split_lines(element:_get_description())\n\n    local result_lines = {}\n\n    -- All label lines should have the same length (except the last one, it has no comma).\n    -- If too long, start description after all the label lines.\n    -- Otherwise, combine label and description lines.\n\n    local usage_margin_len = self:_inherit_property(\"help_usage_margin\", 3)\n    local usage_margin = (\" \"):rep(usage_margin_len)\n    local description_margin_len = self:_inherit_property(\"help_description_margin\", 25)\n    local description_margin = (\" \"):rep(description_margin_len)\n\n    local help_max_width = self:_inherit_property(\"help_max_width\")\n\n    if help_max_width then\n        local description_max_width = math.max(help_max_width - description_margin_len, 10)\n        description_lines = autowrap(description_lines, description_max_width)\n    end\n\n    if #label_lines[1] >= (description_margin_len - usage_margin_len) then\n        for _, label_line in ipairs(label_lines) do\n            table.insert(result_lines, usage_margin .. label_line)\n        end\n\n        for _, description_line in ipairs(description_lines) do\n            table.insert(result_lines, description_margin .. description_line)\n        end\n    else\n        for i = 1, math.max(#label_lines, #description_lines) do\n            local label_line = label_lines[i]\n            local description_line = description_lines[i]\n\n            local line = \"\"\n\n            if label_line then\n                line = usage_margin .. label_line\n            end\n\n            if description_line and description_line ~= \"\" then\n                line = line .. (\" \"):rep(description_margin_len - #line) .. description_line\n            end\n\n            table.insert(result_lines, line)\n        end\n    end\n\n    return table.concat(result_lines, \"\\n\")\nend\n\nlocal function get_group_types(group)\n    local types = {}\n\n    for _, element in ipairs(group) do\n        types[getmetatable(element)] = true\n    end\n\n    return types\nend\n\nfunction Parser:_add_group_help(blocks, added_elements, label, elements)\n    local buf = {label}\n\n    for _, element in ipairs(elements) do\n        if not element._hidden and not added_elements[element] then\n            added_elements[element] = true\n            table.insert(buf, self:_get_element_help(element))\n        end\n    end\n\n    if #buf > 1 then\n        table.insert(blocks, table.concat(buf, (\"\\n\"):rep(self:_inherit_property(\"help_vertical_space\", 0) + 1)))\n    end\nend\n\nfunction Parser:get_help()\n    if self._help then\n        return self._help\n    end\n\n    local blocks = {self:get_usage()}\n\n    local help_max_width = self:_inherit_property(\"help_max_width\")\n\n    if self._description then\n        local description = self._description\n\n        if help_max_width then\n            description = table.concat(autowrap(split_lines(description), help_max_width), \"\\n\")\n        end\n\n        table.insert(blocks, description)\n    end\n\n    -- 1. Put groups containing arguments first, then other arguments.\n    -- 2. Put remaining groups containing options, then other options.\n    -- 3. Put remaining groups containing commands, then other commands.\n    -- Assume that an element can't be in several groups.\n    local groups_by_type = {\n        [Argument] = {},\n        [Option] = {},\n        [Command] = {}\n    }\n\n    for _, group in ipairs(self._groups) do\n        local group_types = get_group_types(group)\n\n        for _, mt in ipairs({Argument, Option, Command}) do\n            if group_types[mt] then\n                table.insert(groups_by_type[mt], group)\n                break\n            end\n        end\n    end\n\n    local default_groups = {\n        {name = \"Arguments\", type = Argument, elements = self._arguments},\n        {name = \"Options\", type = Option, elements = self._options},\n        {name = \"Commands\", type = Command, elements = self._commands}\n    }\n\n    local added_elements = {}\n\n    for _, default_group in ipairs(default_groups) do\n        local type_groups = groups_by_type[default_group.type]\n\n        for _, group in ipairs(type_groups) do\n            self:_add_group_help(blocks, added_elements, group.name .. \":\", group)\n        end\n\n        local default_label = default_group.name .. \":\"\n\n        if #type_groups > 0 then\n            default_label = \"Other \" .. default_label:gsub(\"^.\", string.lower)\n        end\n\n        self:_add_group_help(blocks, added_elements, default_label, default_group.elements)\n    end\n\n    if self._epilog then\n        local epilog = self._epilog\n\n        if help_max_width then\n            epilog = table.concat(autowrap(split_lines(epilog), help_max_width), \"\\n\")\n        end\n\n        table.insert(blocks, epilog)\n    end\n\n    return table.concat(blocks, \"\\n\\n\")\nend\n\nfunction Parser:add_help_command(value)\n    if value then\n        assert(type(value) == \"string\" or type(value) == \"table\",\n                (\"bad argument #1 to 'add_help_command' (string or table expected, got %s)\"):format(type(value)))\n    end\n\n    local help = self:command()\n                     :description \"Show help for commands.\"\n    help:argument \"command\"\n        :description \"The command to show help for.\"\n        :args \"?\"\n        :action(function(_, _, cmd)\n        if not cmd then\n            print(self:get_help())\n            os.exit(0)\n        else\n            for _, command in ipairs(self._commands) do\n                for _, alias in ipairs(command._aliases) do\n                    if alias == cmd then\n                        print(command:get_help())\n                        os.exit(0)\n                    end\n                end\n            end\n        end\n        help:error((\"unknown command '%s'\"):format(cmd))\n    end)\n\n    if value then\n        help = help(value)\n    end\n\n    if not help._name then\n        help \"help\"\n    end\n\n    help._is_help_command = true\n    return self\nend\n\nfunction Parser:_is_shell_safe()\n    if self._basename then\n        if self._basename:find(\"[^%w_%-%+%.]\") then\n            return false\n        end\n    else\n        for _, alias in ipairs(self._aliases) do\n            if alias:find(\"[^%w_%-%+%.]\") then\n                return false\n            end\n        end\n    end\n    for _, option in ipairs(self._options) do\n        for _, alias in ipairs(option._aliases) do\n            if alias:find(\"[^%w_%-%+%.]\") then\n                return false\n            end\n        end\n        if option._choices then\n            for _, choice in ipairs(option._choices) do\n                if choice:find(\"[%s'\\\"]\") then\n                    return false\n                end\n            end\n        end\n    end\n    for _, argument in ipairs(self._arguments) do\n        if argument._choices then\n            for _, choice in ipairs(argument._choices) do\n                if choice:find(\"[%s'\\\"]\") then\n                    return false\n                end\n            end\n        end\n    end\n    for _, command in ipairs(self._commands) do\n        if not command:_is_shell_safe() then\n            return false\n        end\n    end\n    return true\nend\n\nfunction Parser:add_complete(value)\n    if value then\n        assert(type(value) == \"string\" or type(value) == \"table\",\n                (\"bad argument #1 to 'add_complete' (string or table expected, got %s)\"):format(type(value)))\n    end\n\n    local complete = self:option()\n                         :description \"Output a shell completion script for the specified shell.\"\n                         :args(1)\n                         :choices {\"bash\", \"zsh\", \"fish\"}\n                         :action(function(_, _, shell)\n        io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n        os.exit(0)\n    end)\n\n    if value then\n        complete = complete(value)\n    end\n\n    if not complete._name then\n        complete \"--completion\"\n    end\n\n    return self\nend\n\nfunction Parser:add_complete_command(value)\n    if value then\n        assert(type(value) == \"string\" or type(value) == \"table\",\n                (\"bad argument #1 to 'add_complete_command' (string or table expected, got %s)\"):format(type(value)))\n    end\n\n    local complete = self:command()\n                         :description \"Output a shell completion script.\"\n    complete:argument \"shell\"\n            :description \"The shell to output a completion script for.\"\n            :choices {\"bash\", \"zsh\", \"fish\"}\n            :action(function(_, _, shell)\n        io.write(self[\"get_\" .. shell .. \"_complete\"](self))\n        os.exit(0)\n    end)\n\n    if value then\n        complete = complete(value)\n    end\n\n    if not complete._name then\n        complete \"completion\"\n    end\n\n    return self\nend\n\nlocal function base_name(pathname)\n    return pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\") or pathname\nend\n\nlocal function get_short_description(element)\n    local short = element:_get_description():match(\"^(.-)%.%s\")\n    return short or element:_get_description():match(\"^(.-)%.?$\")\nend\n\nfunction Parser:_get_options()\n    local options = {}\n    for _, option in ipairs(self._options) do\n        for _, alias in ipairs(option._aliases) do\n            table.insert(options, alias)\n        end\n    end\n    return table.concat(options, \" \")\nend\n\nfunction Parser:_get_commands()\n    local commands = {}\n    for _, command in ipairs(self._commands) do\n        for _, alias in ipairs(command._aliases) do\n            table.insert(commands, alias)\n        end\n    end\n    return table.concat(commands, \" \")\nend\n\nfunction Parser:_bash_option_args(buf, indent)\n    local opts = {}\n    for _, option in ipairs(self._options) do\n        if option._choices or option._minargs > 0 then\n            local compreply\n            if option._choices then\n                compreply = 'COMPREPLY=($(compgen -W \"' .. table.concat(option._choices, \" \") .. '\" -- \"$cur\"))'\n            else\n                compreply = 'COMPREPLY=($(compgen -f -- \"$cur\"))'\n            end\n            table.insert(opts, (\" \"):rep(indent + 4) .. table.concat(option._aliases, \"|\") .. \")\")\n            table.insert(opts, (\" \"):rep(indent + 8) .. compreply)\n            table.insert(opts, (\" \"):rep(indent + 8) .. \"return 0\")\n            table.insert(opts, (\" \"):rep(indent + 8) .. \";;\")\n        end\n    end\n\n    if #opts > 0 then\n        table.insert(buf, (\" \"):rep(indent) .. 'case \"$prev\" in')\n        table.insert(buf, table.concat(opts, \"\\n\"))\n        table.insert(buf, (\" \"):rep(indent) .. \"esac\\n\")\n    end\nend\n\nfunction Parser:_bash_get_cmd(buf, indent)\n    if #self._commands == 0 then\n        return\n    end\n\n    table.insert(buf, (\" \"):rep(indent) .. 'args=(\"${args[@]:1}\")')\n    table.insert(buf, (\" \"):rep(indent) .. 'for arg in \"${args[@]}\"; do')\n    table.insert(buf, (\" \"):rep(indent + 4) .. 'case \"$arg\" in')\n\n    for _, command in ipairs(self._commands) do\n        table.insert(buf, (\" \"):rep(indent + 8) .. table.concat(command._aliases, \"|\") .. \")\")\n        if self._parent then\n            table.insert(buf, (\" \"):rep(indent + 12) .. 'cmd=\"$cmd ' .. command._name .. '\"')\n        else\n            table.insert(buf, (\" \"):rep(indent + 12) .. 'cmd=\"' .. command._name .. '\"')\n        end\n        table.insert(buf, (\" \"):rep(indent + 12) .. 'opts=\"$opts ' .. command:_get_options() .. '\"')\n        command:_bash_get_cmd(buf, indent + 12)\n        table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n        table.insert(buf, (\" \"):rep(indent + 12) .. \";;\")\n    end\n\n    table.insert(buf, (\" \"):rep(indent + 4) .. \"esac\")\n    table.insert(buf, (\" \"):rep(indent) .. \"done\")\nend\n\nfunction Parser:_bash_cmd_completions(buf)\n    local cmd_buf = {}\n    if self._parent then\n        self:_bash_option_args(cmd_buf, 12)\n    end\n    if #self._commands > 0 then\n        table.insert(cmd_buf, (\" \"):rep(12) .. 'COMPREPLY=($(compgen -W \"' .. self:_get_commands() .. '\" -- \"$cur\"))')\n    elseif self._is_help_command then\n        table.insert(cmd_buf, (\" \"):rep(12)\n                .. 'COMPREPLY=($(compgen -W \"'\n                .. self._parent:_get_commands()\n                .. '\" -- \"$cur\"))')\n    end\n    if #cmd_buf > 0 then\n        table.insert(buf, (\" \"):rep(8) .. \"'\" .. self:_get_fullname(true) .. \"')\")\n        table.insert(buf, table.concat(cmd_buf, \"\\n\"))\n        table.insert(buf, (\" \"):rep(12) .. \";;\")\n    end\n\n    for _, command in ipairs(self._commands) do\n        command:_bash_cmd_completions(buf)\n    end\nend\n\nfunction Parser:get_bash_complete()\n    self._basename = base_name(self._name)\n    assert(self:_is_shell_safe())\n    local buf = {([[\n_%s() {\n    local IFS=$' \\t\\n'\n    local args cur prev cmd opts arg\n    args=(\"${COMP_WORDS[@]}\")\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    opts=\"%s\"\n]]):format(self._basename, self:_get_options())}\n\n    self:_bash_option_args(buf, 4)\n    self:_bash_get_cmd(buf, 4)\n    if #self._commands > 0 then\n        table.insert(buf, \"\")\n        table.insert(buf, (\" \"):rep(4) .. 'case \"$cmd\" in')\n        self:_bash_cmd_completions(buf)\n        table.insert(buf, (\" \"):rep(4) .. \"esac\\n\")\n    end\n\n    table.insert(buf, ([=[\n    if [[ \"$cur\" = -* ]]; then\n        COMPREPLY=($(compgen -W \"$opts\" -- \"$cur\"))\n    fi\n}\n\ncomplete -F _%s -o bashdefault -o default %s\n]=]):format(self._basename, self._basename))\n\n    return table.concat(buf, \"\\n\")\nend\n\nfunction Parser:_zsh_arguments(buf, cmd_name, indent)\n    if self._parent then\n        table.insert(buf, (\" \"):rep(indent) .. \"options=(\")\n        table.insert(buf, (\" \"):rep(indent + 2) .. \"$options\")\n    else\n        table.insert(buf, (\" \"):rep(indent) .. \"local -a options=(\")\n    end\n\n    for _, option in ipairs(self._options) do\n        local line = {}\n        if #option._aliases > 1 then\n            if option._maxcount > 1 then\n                table.insert(line, '\"*\"')\n            end\n            table.insert(line, \"{\" .. table.concat(option._aliases, \",\") .. '}\"')\n        else\n            table.insert(line, '\"')\n            if option._maxcount > 1 then\n                table.insert(line, \"*\")\n            end\n            table.insert(line, option._name)\n        end\n        if option._description then\n            local description = get_short_description(option):gsub('[\"%]:`$]', \"\\\\%0\")\n            table.insert(line, \"[\" .. description .. \"]\")\n        end\n        if option._maxargs == math.huge then\n            table.insert(line, \":*\")\n        end\n        if option._choices then\n            table.insert(line, \": :(\" .. table.concat(option._choices, \" \") .. \")\")\n        elseif option._maxargs > 0 then\n            table.insert(line, \": :_files\")\n        end\n        table.insert(line, '\"')\n        table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(line))\n    end\n\n    table.insert(buf, (\" \"):rep(indent) .. \")\")\n    table.insert(buf, (\" \"):rep(indent) .. \"_arguments -s -S \\\\\")\n    table.insert(buf, (\" \"):rep(indent + 2) .. \"$options \\\\\")\n\n    if self._is_help_command then\n        table.insert(buf, (\" \"):rep(indent + 2) .. '\": :(' .. self._parent:_get_commands() .. ')\" \\\\')\n    else\n        for _, argument in ipairs(self._arguments) do\n            local spec\n            if argument._choices then\n                spec = \": :(\" .. table.concat(argument._choices, \" \") .. \")\"\n            else\n                spec = \": :_files\"\n            end\n            if argument._maxargs == math.huge then\n                table.insert(buf, (\" \"):rep(indent + 2) .. '\"*' .. spec .. '\" \\\\')\n                break\n            end\n            for _ = 1, argument._maxargs do\n                table.insert(buf, (\" \"):rep(indent + 2) .. '\"' .. spec .. '\" \\\\')\n            end\n        end\n\n        if #self._commands > 0 then\n            table.insert(buf, (\" \"):rep(indent + 2) .. '\": :_' .. cmd_name .. '_cmds\" \\\\')\n            table.insert(buf, (\" \"):rep(indent + 2) .. '\"*:: :->args\" \\\\')\n        end\n    end\n\n    table.insert(buf, (\" \"):rep(indent + 2) .. \"&& return 0\")\nend\n\nfunction Parser:_zsh_cmds(buf, cmd_name)\n    table.insert(buf, \"\\n_\" .. cmd_name .. \"_cmds() {\")\n    table.insert(buf, \"  local -a commands=(\")\n\n    for _, command in ipairs(self._commands) do\n        local line = {}\n        if #command._aliases > 1 then\n            table.insert(line, \"{\" .. table.concat(command._aliases, \",\") .. '}\"')\n        else\n            table.insert(line, '\"' .. command._name)\n        end\n        if command._description then\n            table.insert(line, \":\" .. get_short_description(command):gsub('[\"`$]', \"\\\\%0\"))\n        end\n        table.insert(buf, \"    \" .. table.concat(line) .. '\"')\n    end\n\n    table.insert(buf, '  )\\n  _describe \"command\" commands\\n}')\nend\n\nfunction Parser:_zsh_complete_help(buf, cmds_buf, cmd_name, indent)\n    if #self._commands == 0 then\n        return\n    end\n\n    self:_zsh_cmds(cmds_buf, cmd_name)\n    table.insert(buf, \"\\n\" .. (\" \"):rep(indent) .. \"case $words[1] in\")\n\n    for _, command in ipairs(self._commands) do\n        local name = cmd_name .. \"_\" .. command._name\n        table.insert(buf, (\" \"):rep(indent + 2) .. table.concat(command._aliases, \"|\") .. \")\")\n        command:_zsh_arguments(buf, name, indent + 4)\n        command:_zsh_complete_help(buf, cmds_buf, name, indent + 4)\n        table.insert(buf, (\" \"):rep(indent + 4) .. \";;\\n\")\n    end\n\n    table.insert(buf, (\" \"):rep(indent) .. \"esac\")\nend\n\nfunction Parser:get_zsh_complete()\n    self._basename = base_name(self._name)\n    assert(self:_is_shell_safe())\n    local buf = {(\"#compdef %s\\n\"):format(self._basename)}\n    local cmds_buf = {}\n    table.insert(buf, \"_\" .. self._basename .. \"() {\")\n    if #self._commands > 0 then\n        table.insert(buf, \"  local context state state_descr line\")\n        table.insert(buf, \"  typeset -A opt_args\\n\")\n    end\n    self:_zsh_arguments(buf, self._basename, 2)\n    self:_zsh_complete_help(buf, cmds_buf, self._basename, 2)\n    table.insert(buf, \"\\n  return 1\")\n    table.insert(buf, \"}\")\n\n    local result = table.concat(buf, \"\\n\")\n    if #cmds_buf > 0 then\n        result = result .. \"\\n\" .. table.concat(cmds_buf, \"\\n\")\n    end\n    return result .. \"\\n\\n_\" .. self._basename .. \"\\n\"\nend\n\nlocal function fish_escape(string)\n    return string:gsub(\"[\\\\']\", \"\\\\%0\")\nend\n\nfunction Parser:_fish_get_cmd(buf, indent)\n    if #self._commands == 0 then\n        return\n    end\n\n    table.insert(buf, (\" \"):rep(indent) .. \"set -e cmdline[1]\")\n    table.insert(buf, (\" \"):rep(indent) .. \"for arg in $cmdline\")\n    table.insert(buf, (\" \"):rep(indent + 4) .. \"switch $arg\")\n\n    for _, command in ipairs(self._commands) do\n        table.insert(buf, (\" \"):rep(indent + 8) .. \"case \" .. table.concat(command._aliases, \" \"))\n        table.insert(buf, (\" \"):rep(indent + 12) .. \"set cmd $cmd \" .. command._name)\n        command:_fish_get_cmd(buf, indent + 12)\n        table.insert(buf, (\" \"):rep(indent + 12) .. \"break\")\n    end\n\n    table.insert(buf, (\" \"):rep(indent + 4) .. \"end\")\n    table.insert(buf, (\" \"):rep(indent) .. \"end\")\nend\n\nfunction Parser:_fish_complete_help(buf, basename)\n    local prefix = \"complete -c \" .. basename\n    table.insert(buf, \"\")\n\n    for _, command in ipairs(self._commands) do\n        local aliases = table.concat(command._aliases, \" \")\n        local line\n        if self._parent then\n            line = (\"%s -n '__fish_%s_using_command %s' -xa '%s'\")\n                    :format(prefix, basename, self:_get_fullname(true), aliases)\n        else\n            line = (\"%s -n '__fish_%s_using_command' -xa '%s'\"):format(prefix, basename, aliases)\n        end\n        if command._description then\n            line = (\"%s -d '%s'\"):format(line, fish_escape(get_short_description(command)))\n        end\n        table.insert(buf, line)\n    end\n\n    if self._is_help_command then\n        local line = (\"%s -n '__fish_%s_using_command %s' -xa '%s'\")\n                :format(prefix, basename, self:_get_fullname(true), self._parent:_get_commands())\n        table.insert(buf, line)\n    end\n\n    for _, option in ipairs(self._options) do\n        local parts = {prefix}\n\n        if self._parent then\n            table.insert(parts, \"-n '__fish_\" .. basename .. \"_seen_command \" .. self:_get_fullname(true) .. \"'\")\n        end\n\n        for _, alias in ipairs(option._aliases) do\n            if alias:match(\"^%-.$\") then\n                table.insert(parts, \"-s \" .. alias:sub(2))\n            elseif alias:match(\"^%-%-.+\") then\n                table.insert(parts, \"-l \" .. alias:sub(3))\n            end\n        end\n\n        if option._choices then\n            table.insert(parts, \"-xa '\" .. table.concat(option._choices, \" \") .. \"'\")\n        elseif option._minargs > 0 then\n            table.insert(parts, \"-r\")\n        end\n\n        if option._description then\n            table.insert(parts, \"-d '\" .. fish_escape(get_short_description(option)) .. \"'\")\n        end\n\n        table.insert(buf, table.concat(parts, \" \"))\n    end\n\n    for _, command in ipairs(self._commands) do\n        command:_fish_complete_help(buf, basename)\n    end\nend\n\nfunction Parser:get_fish_complete()\n    self._basename = base_name(self._name)\n    assert(self:_is_shell_safe())\n    local buf = {}\n\n    if #self._commands > 0 then\n        table.insert(buf, ([[\nfunction __fish_%s_print_command\n    set -l cmdline (commandline -poc)\n    set -l cmd]]):format(self._basename))\n        self:_fish_get_cmd(buf, 4)\n        table.insert(buf, ([[\n    echo \"$cmd\"\nend\n\nfunction __fish_%s_using_command\n    test (__fish_%s_print_command) = \"$argv\"\n    and return 0\n    or return 1\nend\n\nfunction __fish_%s_seen_command\n    string match -q \"$argv*\" (__fish_%s_print_command)\n    and return 0\n    or return 1\nend]]):format(self._basename, self._basename, self._basename, self._basename))\n    end\n\n    self:_fish_complete_help(buf, self._basename)\n    return table.concat(buf, \"\\n\") .. \"\\n\"\nend\n\nlocal function get_tip(context, wrong_name)\n    local context_pool = {}\n    local possible_name\n    local possible_names = {}\n\n    for name in pairs(context) do\n        if type(name) == \"string\" then\n            for i = 1, #name do\n                possible_name = name:sub(1, i - 1) .. name:sub(i + 1)\n\n                if not context_pool[possible_name] then\n                    context_pool[possible_name] = {}\n                end\n\n                table.insert(context_pool[possible_name], name)\n            end\n        end\n    end\n\n    for i = 1, #wrong_name + 1 do\n        possible_name = wrong_name:sub(1, i - 1) .. wrong_name:sub(i + 1)\n\n        if context[possible_name] then\n            possible_names[possible_name] = true\n        elseif context_pool[possible_name] then\n            for _, name in ipairs(context_pool[possible_name]) do\n                possible_names[name] = true\n            end\n        end\n    end\n\n    local first = next(possible_names)\n\n    if first then\n        if next(possible_names, first) then\n            local possible_names_arr = {}\n\n            for name in pairs(possible_names) do\n                table.insert(possible_names_arr, \"'\" .. name .. \"'\")\n            end\n\n            table.sort(possible_names_arr)\n            return \"\\nDid you mean one of these: \" .. table.concat(possible_names_arr, \" \") .. \"?\"\n        else\n            return \"\\nDid you mean '\" .. first .. \"'?\"\n        end\n    else\n        return \"\"\n    end\nend\n\nlocal ElementState = class({\n    invocations = 0\n})\n\nfunction ElementState:__call(state, element)\n    self.state = state\n    self.result = state.result\n    self.element = element\n    self.target = element._target or element:_get_default_target()\n    self.action, self.result[self.target] = element:_get_action()\n    return self\nend\n\nfunction ElementState:error(fmt, ...)\n    self.state:error(fmt, ...)\nend\n\nfunction ElementState:convert(argument, index)\n    local converter = self.element._convert\n\n    if converter then\n        local ok, err\n\n        if type(converter) == \"function\" then\n            ok, err = converter(argument)\n        elseif type(converter[index]) == \"function\" then\n            ok, err = converter[index](argument)\n        else\n            ok = converter[argument]\n        end\n\n        if ok == nil then\n            self:error(err and \"%s\" or \"malformed argument '%s'\", err or argument)\n        end\n\n        argument = ok\n    end\n\n    return argument\nend\n\nfunction ElementState:default(mode)\n    return self.element._defmode:find(mode) and self.element._default\nend\n\nlocal function bound(noun, min, max, is_max)\n    local res = \"\"\n\n    if min ~= max then\n        res = \"at \" .. (is_max and \"most\" or \"least\") .. \" \"\n    end\n\n    local number = is_max and max or min\n    return res .. tostring(number) .. \" \" .. noun ..  (number == 1 and \"\" or \"s\")\nend\n\nfunction ElementState:set_name(alias)\n    self.name = (\"%s '%s'\"):format(alias and \"option\" or \"argument\", alias or self.element._name)\nend\n\nfunction ElementState:invoke()\n    self.open = true\n    self.overwrite = false\n\n    if self.invocations >= self.element._maxcount then\n        if self.element._overwrite then\n            self.overwrite = true\n        else\n            local num_times_repr = bound(\"time\", self.element._mincount, self.element._maxcount, true)\n            self:error(\"%s must be used %s\", self.name, num_times_repr)\n        end\n    else\n        self.invocations = self.invocations + 1\n    end\n\n    self.args = {}\n\n    if self.element._maxargs <= 0 then\n        self:close()\n    end\n\n    return self.open\nend\n\nfunction ElementState:check_choices(argument)\n    if self.element._choices then\n        for _, choice in ipairs(self.element._choices) do\n            if argument == choice then\n                return\n            end\n        end\n        local choices_list = \"'\" .. table.concat(self.element._choices, \"', '\") .. \"'\"\n        local is_option = getmetatable(self.element) == Option\n        self:error(\"%s%s must be one of %s\", is_option and \"argument for \" or \"\", self.name, choices_list)\n    end\nend\n\nfunction ElementState:pass(argument)\n    self:check_choices(argument)\n    argument = self:convert(argument, #self.args + 1)\n    table.insert(self.args, argument)\n\n    if #self.args >= self.element._maxargs then\n        self:close()\n    end\n\n    return self.open\nend\n\nfunction ElementState:complete_invocation()\n    while #self.args < self.element._minargs do\n        self:pass(self.element._default)\n    end\nend\n\nfunction ElementState:close()\n    if self.open then\n        self.open = false\n\n        if #self.args < self.element._minargs then\n            if self:default(\"a\") then\n                self:complete_invocation()\n            else\n                if #self.args == 0 then\n                    if getmetatable(self.element) == Argument then\n                        self:error(\"missing %s\", self.name)\n                    elseif self.element._maxargs == 1 then\n                        self:error(\"%s requires an argument\", self.name)\n                    end\n                end\n\n                self:error(\"%s requires %s\", self.name, bound(\"argument\", self.element._minargs, self.element._maxargs))\n            end\n        end\n\n        local args\n\n        if self.element._maxargs == 0 then\n            args = self.args[1]\n        elseif self.element._maxargs == 1 then\n            if self.element._minargs == 0 and self.element._mincount ~= self.element._maxcount then\n                args = self.args\n            else\n                args = self.args[1]\n            end\n        else\n            args = self.args\n        end\n\n        self.action(self.result, self.target, args, self.overwrite)\n    end\nend\n\nlocal ParseState = class({\n    result = {},\n    options = {},\n    arguments = {},\n    argument_i = 1,\n    element_to_mutexes = {},\n    mutex_to_element_state = {},\n    command_actions = {}\n})\n\nfunction ParseState:__call(parser, error_handler)\n    self.parser = parser\n    self.error_handler = error_handler\n    self.charset = parser:_update_charset()\n    self:switch(parser)\n    return self\nend\n\nfunction ParseState:error(fmt, ...)\n    self.error_handler(self.parser, fmt:format(...))\nend\n\nfunction ParseState:switch(parser)\n    self.parser = parser\n\n    if parser._action then\n        table.insert(self.command_actions, {action = parser._action, name = parser._name})\n    end\n\n    for _, option in ipairs(parser._options) do\n        option = ElementState(self, option)\n        table.insert(self.options, option)\n\n        for _, alias in ipairs(option.element._aliases) do\n            self.options[alias] = option\n        end\n    end\n\n    for _, mutex in ipairs(parser._mutexes) do\n        for _, element in ipairs(mutex) do\n            if not self.element_to_mutexes[element] then\n                self.element_to_mutexes[element] = {}\n            end\n\n            table.insert(self.element_to_mutexes[element], mutex)\n        end\n    end\n\n    for _, argument in ipairs(parser._arguments) do\n        argument = ElementState(self, argument)\n        table.insert(self.arguments, argument)\n        argument:set_name()\n        argument:invoke()\n    end\n\n    self.handle_options = parser._handle_options\n    self.argument = self.arguments[self.argument_i]\n    self.commands = parser._commands\n\n    for _, command in ipairs(self.commands) do\n        for _, alias in ipairs(command._aliases) do\n            self.commands[alias] = command\n        end\n    end\nend\n\nfunction ParseState:get_option(name)\n    local option = self.options[name]\n\n    if not option then\n        self:error(\"unknown option '%s'%s\", name, get_tip(self.options, name))\n    else\n        return option\n    end\nend\n\nfunction ParseState:get_command(name)\n    local command = self.commands[name]\n\n    if not command then\n        if #self.commands > 0 then\n            self:error(\"unknown command '%s'%s\", name, get_tip(self.commands, name))\n        else\n            self:error(\"too many arguments\")\n        end\n    else\n        return command\n    end\nend\n\nfunction ParseState:check_mutexes(element_state)\n    if self.element_to_mutexes[element_state.element] then\n        for _, mutex in ipairs(self.element_to_mutexes[element_state.element]) do\n            local used_element_state = self.mutex_to_element_state[mutex]\n\n            if used_element_state and used_element_state ~= element_state then\n                self:error(\"%s can not be used together with %s\", element_state.name, used_element_state.name)\n            else\n                self.mutex_to_element_state[mutex] = element_state\n            end\n        end\n    end\nend\n\nfunction ParseState:invoke(option, name)\n    self:close()\n    option:set_name(name)\n    self:check_mutexes(option, name)\n\n    if option:invoke() then\n        self.option = option\n    end\nend\n\nfunction ParseState:pass(arg)\n    if self.option then\n        if not self.option:pass(arg) then\n            self.option = nil\n        end\n    elseif self.argument then\n        self:check_mutexes(self.argument)\n\n        if not self.argument:pass(arg) then\n            self.argument_i = self.argument_i + 1\n            self.argument = self.arguments[self.argument_i]\n        end\n    else\n        local command = self:get_command(arg)\n        self.result[command._target or command._name] = true\n\n        if self.parser._command_target then\n            self.result[self.parser._command_target] = command._name\n        end\n\n        self:switch(command)\n    end\nend\n\nfunction ParseState:close()\n    if self.option then\n        self.option:close()\n        self.option = nil\n    end\nend\n\nfunction ParseState:finalize()\n    self:close()\n\n    for i = self.argument_i, #self.arguments do\n        local argument = self.arguments[i]\n        if #argument.args == 0 and argument:default(\"u\") then\n            argument:complete_invocation()\n        else\n            argument:close()\n        end\n    end\n\n    if self.parser._require_command and #self.commands > 0 then\n        self:error(\"a command is required\")\n    end\n\n    for _, option in ipairs(self.options) do\n        option.name = option.name or (\"option '%s'\"):format(option.element._name)\n\n        if option.invocations == 0 then\n            if option:default(\"u\") then\n                option:invoke()\n                option:complete_invocation()\n                option:close()\n            end\n        end\n\n        local mincount = option.element._mincount\n\n        if option.invocations < mincount then\n            if option:default(\"a\") then\n                while option.invocations < mincount do\n                    option:invoke()\n                    option:close()\n                end\n            elseif option.invocations == 0 then\n                self:error(\"missing %s\", option.name)\n            else\n                self:error(\"%s must be used %s\", option.name, bound(\"time\", mincount, option.element._maxcount))\n            end\n        end\n    end\n\n    for i = #self.command_actions, 1, -1 do\n        self.command_actions[i].action(self.result, self.command_actions[i].name)\n    end\nend\n\nfunction ParseState:parse(args)\n    for _, arg in ipairs(args) do\n        local plain = true\n\n        if self.handle_options then\n            local first = arg:sub(1, 1)\n\n            if self.charset[first] then\n                if #arg > 1 then\n                    plain = false\n\n                    if arg:sub(2, 2) == first then\n                        if #arg == 2 then\n                            if self.options[arg] then\n                                local option = self:get_option(arg)\n                                self:invoke(option, arg)\n                            else\n                                self:close()\n                            end\n\n                            self.handle_options = false\n                        else\n                            local equals = arg:find \"=\"\n                            if equals then\n                                local name = arg:sub(1, equals - 1)\n                                local option = self:get_option(name)\n\n                                if option.element._maxargs <= 0 then\n                                    self:error(\"option '%s' does not take arguments\", name)\n                                end\n\n                                self:invoke(option, name)\n                                self:pass(arg:sub(equals + 1))\n                            else\n                                local option = self:get_option(arg)\n                                self:invoke(option, arg)\n                            end\n                        end\n                    else\n                        for i = 2, #arg do\n                            local name = first .. arg:sub(i, i)\n                            local option = self:get_option(name)\n                            self:invoke(option, name)\n\n                            if i ~= #arg and option.element._maxargs > 0 then\n                                self:pass(arg:sub(i + 1))\n                                break\n                            end\n                        end\n                    end\n                end\n            end\n        end\n\n        if plain then\n            self:pass(arg)\n        end\n    end\n\n    self:finalize()\n    return self.result\nend\n\nfunction Parser:error(msg)\n    io.stderr:write((\"%s\\n\\nError: %s\\n\"):format(self:get_usage(), msg))\n    os.exit(1)\nend\n\n-- Compatibility with strict.lua and other checkers:\nlocal default_cmdline = rawget(_G, \"arg\") or {}\n\nfunction Parser:_parse(args, error_handler)\n    return ParseState(self, error_handler):parse(args or default_cmdline)\nend\n\nfunction Parser:parse(args)\n    return self:_parse(args, self.error)\nend\n\nlocal function xpcall_error_handler(err)\n    return tostring(err) .. \"\\noriginal \" .. debug.traceback(\"\", 2):sub(2)\nend\n\nfunction Parser:pparse(args)\n    local parse_error\n\n    local ok, result = xpcall(function()\n        return self:_parse(args, function(_, err)\n            parse_error = err\n            error(err, 0)\n        end)\n    end, xpcall_error_handler)\n\n    if ok then\n        return true, result\n    elseif not parse_error then\n        error(result, 0)\n    else\n        return false, parse_error\n    end\nend\n\nlocal argparse = {}\n\nargparse.version = \"0.7.1\"\n\nsetmetatable(argparse, {__call = function(_, ...)\n    return Parser(default_cmdline[0]):add_help(true)(...)\nend})\n\nreturn argparse\n"
